package main

import (
    "encoding/json"
    "fmt"
    "github.com/0xAX/notificator"
    "github.com/boltdb/bolt"
    "github.com/donkeysharp/golondrina/github"
    "github.com/robfig/cron"
    "io/ioutil"
    "log"
    "math/rand"
    "net/http"
    "os"
    "time"
)

func getData() {
    githubUrl := "https://ghe.coxautoinc.com/api/v3/issues"

    fmt.Println("Starting Golondrina...")
    fmt.Println("Reading environment variable")

    token := os.Getenv("AUTH_TOKEN")
    if len(token) == 0 {
        fmt.Println("No token")
        os.Exit(1)
    }

    fmt.Printf("Token: %s...\n", token[0:10])

    client := http.Client{}

    request, _ := http.NewRequest("GET", githubUrl, nil)
    request.Header.Add("Authorization", fmt.Sprintf("token %s", token))

    response, err := client.Do(request)
    if err != nil {
        fmt.Println("It failed", err)
        os.Exit(1)
    }
    defer response.Body.Close()

    repsonseBytes, err := ioutil.ReadAll(response.Body)
    if err != nil {
        fmt.Println("Error reading response")
        os.Exit(1)
    }

    var issues []map[string]interface{}
    err = json.Unmarshal(repsonseBytes, &issues)
    if err != nil {
        fmt.Println("error parsing json")
        fmt.Println(err)
        os.Exit(1)
    }

    for _, issue := range issues {
        title := issue["title"]
        isPullRequest := issue["pull_request"]
        if isPullRequest != nil {
            fmt.Printf("\"%s\" is a pull request\n", title)
        }
    }

}

func writeToBolt(db *bolt.DB, bucketName, key string) error {
    log.Printf("Reading from %s and %s\n", bucketName, key)

    rand.Seed(time.Now().UTC().UnixNano())
    err := db.Update(func(tx *bolt.Tx) error {
        bucket, err := tx.CreateBucketIfNotExists([]byte(bucketName))
        if err != nil {
            return fmt.Errorf("Create bucket: %s", err)
        }

        randValue := rand.Intn(100)

        bucket.Put([]byte(key), []byte(fmt.Sprintf("Fernando -> %d", randValue)))

        return nil
    })
    return err
}

func readFromBolt(db *bolt.DB, bucketName, key string) error {
    log.Printf("Writing to %s and %s\n", bucketName, key)
    err := db.View(func(tx *bolt.Tx) error {
        bucket := tx.Bucket([]byte(bucketName))
        value := bucket.Get([]byte(key))
        log.Printf("Bucket: %s Key: %s Value: %s\n", bucketName, key, value)

        return nil
    })
    return err
}

const (
    BUCKET = "github_issues"
    KEY    = "some_data"
)

func boltStuff() {
    var option int

    fmt.Println("Choose an option:")
    fmt.Println("1 read")
    fmt.Println("2 write")
    fmt.Scanf("%d", &option)

    db, err := bolt.Open("my.db", 0600, nil)
    if err != nil {
        log.Fatal("Error opening database file")
    }
    defer db.Close()

    if option == 1 {

        log.Println("Reading data")
        log.Println("Key: ")
        readFromBolt(db, BUCKET, KEY)
    } else if option == 2 {
        log.Println("Writing data")
        writeToBolt(db, BUCKET, KEY)
    }

}

func scheduledJob() {
    log.Println("================")
    log.Println("Executing job at: ")
    log.Println(time.Now().String())
    log.Println("================")
}

func cronStuff() {
    scheduler := cron.New()
    scheduler.AddFunc("0 * * * *", scheduledJob)
    scheduler.Run()
}

func main() {
    notify := notificator.New(notificator.Options{
        DefaultIcon: "icon/default.png",
        AppName:     "Golondrina",
    })

    token := os.Getenv("AUTH_TOKEN")
    githubHost := os.Getenv("GITHUB_HOST")
    if githubHost == "" {
        githubHost = "github.com"
    }

    time.Sleep(1 * time.Second)
    notify.Push("New Pull Request", "A new pull request for ReconMVS/recon-app", "", notificator.UR_NORMAL)
    p := github.Parser{
        Host:  "ghe.coxautoinc.com",
        Token: token,
    }
    notifications, _ := p.GetNotifications()
    fmt.Println(notifications)
}
